<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood Recommender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&family=Vazirmatn:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Base font */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0b14 0%, #1a1b2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Animated background particles */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.1), transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(139,92,246,0.2), transparent),
                radial-gradient(1px 1px at 90px 40px, rgba(59,130,246,0.15), transparent),
                radial-gradient(1px 1px at 130px 80px, rgba(236,72,153,0.1), transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: sparkle 20s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes sparkle {
            0% { transform: translateX(0); }
            100% { transform: translateX(-200px); }
        }
        
        /* Persian font override */
        html[lang="fa"] body {
            font-family: 'Vazirmatn', sans-serif;
        }
        
        .card-enter {
            animation: card-enter 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            opacity: 0;
            transform: translateY(40px) scale(0.95) rotateX(10deg);
        }
        @keyframes card-enter {
            0% {
                opacity: 0;
                transform: translateY(40px) scale(0.95) rotateX(10deg);
            }
            60% {
                opacity: 0.8;
                transform: translateY(-5px) scale(1.02) rotateX(-2deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateX(0deg);
            }
        }
        
        /* Enhanced Loader Animation */
        .film-loader {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            position: relative;
            background: conic-gradient(from 0deg, #8b5cf6, #3b82f6, #ec4899, #8b5cf6);
            animation: spin 2s linear infinite, pulse 3s ease-in-out infinite;
            margin: 0 auto;
            box-shadow: 0 0 40px rgba(139, 92, 246, 0.4), inset 0 0 20px rgba(0,0,0,0.3);
        }
        .film-loader::before {
            content: '';
            position: absolute;
            inset: 12px;
            background: radial-gradient(circle, #10121b 30%, transparent 70%);
            border-radius: 50%;
            z-index: 1;
            box-shadow: inset 0 0 20px rgba(139, 92, 246, 0.2);
        }
        .film-loader::after {
            content: '';
            position: absolute;
            inset: 0;
            background: conic-gradient(from 45deg, transparent, rgba(139, 92, 246, 0.8), transparent);
            border-radius: 50%;
            z-index: 0;
            animation: projector-flicker 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        @keyframes projector-flicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        .segmented-control button.active {
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            color: white;
            font-weight: 700;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4), 0 0 20px rgba(139, 92, 246, 0.2);
            transform: scale(1.05);
        }
        
        .segmented-control button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .segmented-control button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .segmented-control button:hover::before {
            left: 100%;
        }
        
        .horizontal-scroll-container {
            display: flex;
            overflow-x: auto;
            padding-bottom: 1rem;
            gap: 2rem;
            scroll-behavior: smooth;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            scroll-padding: 1rem;
        }
        .horizontal-scroll-container::-webkit-scrollbar { display: none; }
        
        /* Enhanced scroll snap for better navigation */
        .item-card {
            scroll-snap-align: start;
            scroll-snap-stop: normal;
        }
        
        /* Smooth momentum scrolling for mobile */
        .horizontal-scroll-container {
            -webkit-overflow-scrolling: touch;
        }
        
        .item-card {
            flex: 0 0 260px;
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border-radius: 1rem;
            overflow: hidden;
            position: relative;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(139, 92, 246, 0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .item-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(59, 130, 246, 0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 1;
        }
        
        .item-card:hover {
            transform: translateY(-12px) scale(1.02);
            box-shadow: 0 25px 50px rgba(0,0,0,0.5), 0 0 30px rgba(139, 92, 246, 0.3);
            border-color: rgba(139, 92, 246, 0.4);
        }
        
        .item-card:hover::before {
            opacity: 1;
        }
        .item-card .poster-container {
            width: 100%;
            height: 350px;
            overflow: hidden;
            position: relative;
        }
        .item-card img, .item-card .placeholder-svg {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease;
        }
        .item-card:hover img, .item-card:hover .placeholder-svg {
            transform: scale(1.1);
        }
        .item-card .card-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 20%, transparent);
        }
        html[lang="fa"] .item-card .card-info { text-align: right; }
        .item-card .card-title { font-weight: bold; color: white; }
        .item-card .card-subtitle { font-size: 0.8rem; color: #d1d5db; }
        .item-card .card-reason {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(16, 18, 27, 0.95);
            backdrop-filter: blur(4px);
            padding: 1rem; color: #e5e7eb; font-size: 0.85rem;
            opacity: 0; transform: translateY(100%);
            transition: opacity 0.4s ease, transform 0.4s ease;
            height: 100%; display: flex; align-items: center; justify-content: center; text-align: center;
        }
        html[lang="fa"] .item-card .card-reason { text-align: right; justify-content: flex-end; }
        .item-card:hover .card-reason { opacity: 1; transform: translateY(0); }
        
        .scroll-button {
            position: absolute; top: 50%; transform: translateY(-50%); z-index: 10;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(59, 130, 246, 0.9));
            backdrop-filter: blur(15px);
            color: white; border-radius: 50%;
            width: 55px; height: 55px; display: flex; align-items: center; justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0; pointer-events: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4), 0 0 20px rgba(139, 92, 246, 0.3);
            font-size: 1.2rem;
        }
        .scroll-button:hover { 
            background: linear-gradient(135deg, rgba(139, 92, 246, 1), rgba(59, 130, 246, 1));
            transform: translateY(-50%) scale(1.15) rotate(5deg);
            box-shadow: 0 15px 40px rgba(139, 92, 246, 0.5), 0 0 30px rgba(139, 92, 246, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .scroll-button:active {
            transform: translateY(-50%) scale(0.95);
            transition: all 0.1s ease;
        }
        .scroll-wrapper:hover .scroll-button:not(.disabled) { 
            opacity: 1; 
            pointer-events: auto;
            animation: fadeInBounce 0.3s ease-out;
        }
        .scroll-button.prev { left: 10px; }
        html[lang="fa"] .scroll-button.prev { left: auto; right: 10px; }
        .scroll-button.next { right: 10px; }
        html[lang="fa"] .scroll-button.next { right: auto; left: 10px; }
        .scroll-button.disabled { 
            opacity: 0.2 !important; 
            cursor: not-allowed; 
            pointer-events: none;
            filter: grayscale(1);
        }
        
        @keyframes fadeInBounce {
            0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
            60% { opacity: 1; transform: translateY(-50%) scale(1.1); }
            100% { opacity: 1; transform: translateY(-50%) scale(1); }
        }

        .card-footer {
            padding: 1rem; margin-top: auto; 
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(15, 23, 42, 0.9));
            backdrop-filter: blur(10px);
            display: flex; justify-content: center; align-items: center; gap: 0.75rem;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
        }
        .footer-button {
            flex-grow: 1; text-align: center; padding: 0.7rem 0.6rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6, #ec4899);
            background-size: 200% 200%;
            color: white; font-weight: bold; border-radius: 0.75rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.85rem; white-space: nowrap; 
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), 0 0 15px rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .footer-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        .footer-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 12px 30px rgba(139, 92, 246, 0.4), 0 0 25px rgba(139, 92, 246, 0.3);
            background-position: 100% 100%;
        }
        
        .footer-button:hover::before {
            left: 100%;
        }
        
        .footer-divider { 
            width: 2px; height: 1.5rem; 
            background: linear-gradient(to bottom, transparent, rgba(139, 92, 246, 0.5), transparent);
            flex-shrink: 0; 
        }
        
        /* Enhanced Favorites & Rating Buttons */
        .favorite-btn {
            position: absolute; top: 0.75rem; right: 0.75rem;
            z-index: 5; 
            background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(31, 41, 55, 0.8));
            backdrop-filter: blur(10px);
            border-radius: 50%;
            width: 42px; height: 42px; display: flex; align-items: center; justify-content: center;
            color: #d1d5db; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .favorite-btn:hover { 
            transform: scale(1.15) rotate(5deg);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.8), rgba(236, 72, 153, 0.8));
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
        }
        .favorite-btn.favorited { 
            color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.3));
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        html[lang="fa"] .favorite-btn { right: auto; left: 0.75rem; }

        .imdb-rating {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            z-index: 5;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(31, 41, 55, 0.9));
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.4rem 0.7rem;
            color: #fbbf24;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            border: 1px solid rgba(251, 191, 36, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 0 10px rgba(251, 191, 36, 0.2);
            transition: all 0.3s ease;
        }
        
        .imdb-rating:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.3);
        }
        
        html[lang="fa"] .imdb-rating {
            left: auto;
            right: 0.75rem;
        }

        .favorites-modal-container {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.8); backdrop-filter: blur(8px);
            z-index: 50; display: flex; justify-content: center; align-items: center;
        }
        #favorites-modal-content {
            background-color: #10121b; border: 1px solid #374151;
            width: 90%; max-width: 800px; max-height: 80vh;
            border-radius: 1rem; padding: 1.5rem; overflow-y: auto;
        }
        .streaming-links {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
        }
        .streaming-links a { 
            color: #9ca3af; 
            transition: color 0.2s ease, transform 0.2s ease; 
            font-size: 1.5rem;
        }
        .streaming-links a.spotify:hover { color: #1DB954; transform: scale(1.1); }
        .streaming-links a.youtube:hover { color: #FF0000; transform: scale(1.1); }
        .streaming-links a.soundcloud:hover { color: #FF5500; transform: scale(1.1); }
    </style>
</head>
<body class="text-gray-200 min-h-screen flex flex-col items-center p-4 transition-all duration-500">

    <div id="main-content" class="w-full max-w-6xl mx-auto text-center">
        <!-- Header Buttons -->
        <div class="absolute top-4 right-4 z-10 flex gap-4">
             <button id="favorites-open-btn" class="w-10 h-10 flex items-center justify-center bg-gray-800/80 rounded-full text-white text-lg"><i class="fas fa-heart"></i></button>
             <div id="lang-switcher-container">
                <div id="lang-switcher" class="segmented-control flex items-center bg-gray-800/80 p-1 rounded-full">
                    <button data-lang="en" class="active px-2 py-1 text-sm sm:px-4 rounded-full transition-colors duration-300">English</button>
                    <button data-lang="fa" class="px-2 py-1 text-sm sm:px-4 rounded-full transition-colors duration-300">فارسی</button>
                </div>
            </div>
        </div>

        <!-- Header -->
        <header id="header" class="mb-4 transition-all duration-500 pt-20">
            <h1 id="header-title" class="text-4xl sm:text-5xl md:text-6xl font-black bg-clip-text text-transparent bg-gradient-to-r from-blue-400 via-purple-500 to-pink-500 mb-2">Find Your Vibe</h1>
            <p id="header-subtitle" class="text-base sm:text-lg text-gray-400">Describe your mood, I'll handle the magic!</p>
            <p id="header-explanation" class="text-gray-500 text-sm sm:text-base max-w-2xl mx-auto mt-4"></p>
        </header>

        <!-- Options Panel -->
         <div id="options-panel" class="mb-6 max-w-4xl mx-auto w-full flex flex-col items-center gap-4">
             <div class="bg-gradient-to-r from-gray-800/90 to-gray-900/95 backdrop-blur-10 p-4 rounded-2xl text-white border border-purple-500/20 shadow-xl shadow-purple-500/10 w-full">
                 <div class="flex flex-col lg:flex-row items-center justify-center gap-4">
                     <div id="year-filter-container" class="flex items-center gap-3">
                         <label id="year-range-label" for="year-from" class="font-bold text-sm text-purple-300 whitespace-nowrap">Year Range:</label>
                         <input type="number" id="year-from" placeholder="1990" class="w-24 p-2 bg-gray-700/80 border border-purple-500/30 rounded-xl text-center appearance-none focus:ring-2 focus:ring-purple-400 focus:border-purple-400 transition-all duration-300 backdrop-blur-5">
                         <span class="text-purple-400 font-bold">-</span>
                         <input type="number" id="year-to" class="w-24 p-2 bg-gray-700/80 border border-purple-500/30 rounded-xl text-center appearance-none focus:ring-2 focus:ring-purple-400 focus:border-purple-400 transition-all duration-300 backdrop-blur-5">
                     </div>
                     <div class="hidden lg:block w-px h-8 bg-purple-500/30"></div>
                     <div id="genre-filter-container" class="flex items-center gap-3 flex-1 lg:max-w-md">
                         <label id="genre-label" for="genre-input" class="font-bold text-sm text-purple-300 whitespace-nowrap">Genre:</label>
                         <input type="text" id="genre-input" placeholder="Action, Comedy, Drama..." class="flex-1 p-2 bg-gray-700/80 border border-purple-500/30 rounded-xl text-center appearance-none focus:ring-2 focus:ring-purple-400 focus:border-purple-400 transition-all duration-300 backdrop-blur-5">
                     </div>
                 </div>
                 <p id="optional-note" class="text-center text-xs text-gray-400 mt-3">(Year and genre are optional)</p>
             </div>
        </div>
        
        <!-- Enhanced Input Form -->
        <form id="mood-form" class="mb-8 max-w-xl mx-auto w-full">
            <div class="relative">
                <textarea id="mood-input" class="w-full p-6 bg-gradient-to-br from-gray-800/90 to-gray-900/95 border-2 border-purple-500/30 rounded-2xl text-white placeholder-gray-400 focus:outline-none focus:ring-4 focus:ring-purple-500/30 focus:border-purple-400 transition-all duration-300 resize-none backdrop-blur-10 shadow-2xl shadow-purple-500/10" rows="4" placeholder="e.g., I feel super energetic and happy today..."></textarea>
                <div class="absolute inset-0 rounded-2xl bg-gradient-to-r from-purple-500/10 via-transparent to-blue-500/10 pointer-events-none"></div>
            </div>
            <button id="submit-button" type="submit" class="mt-6 w-full px-8 py-4 bg-gradient-to-r from-blue-500 via-purple-600 to-pink-500 bg-size-200 text-white font-bold rounded-2xl hover:scale-105 hover:bg-pos-100 transform transition-all duration-300 ease-in-out shadow-2xl shadow-purple-500/30 border border-white/10 relative overflow-hidden group">
                <span class="relative z-10">Get Recommendations</span>
                <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
            </button>
        </form>

        <!-- Loading Indicator -->
        <div id="loader" class="hidden my-8">
            <div class="film-loader"></div>
            <p id="loader-text" class="mt-6 text-gray-400 text-lg"></p>
        </div>
        
        <!-- Error Message -->
        <div id="error-message" class="hidden my-8 p-4 bg-red-900/50 border border-red-700 rounded-lg text-red-300">
             <p id="error-text">Sorry, something went wrong. Please try again.</p>
        </div>

        <!-- Results Section -->
        <div id="results" class="hidden w-full">
             <div id="reset-container" class="text-center mt-12 flex justify-center gap-6">
                <button id="refresh-button" class="px-8 py-4 bg-gradient-to-r from-blue-500 via-purple-600 to-pink-500 bg-size-200 text-white font-bold rounded-2xl hover:scale-105 hover:bg-pos-100 transform transition-all duration-300 ease-in-out shadow-2xl shadow-purple-500/30 border border-white/10 relative overflow-hidden group">
                    <span class="relative z-10">New Suggestions</span>
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                </button>
                <button id="reset-button" class="px-8 py-4 bg-gradient-to-r from-gray-700 to-gray-800 text-white font-bold rounded-2xl hover:scale-105 hover:from-gray-600 hover:to-gray-700 transform transition-all duration-300 ease-in-out shadow-xl shadow-gray-500/20 border border-gray-600/50 relative overflow-hidden group">
                    <span class="relative z-10">Try Again</span>
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent transform -skew-x-12 -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                </button>
             </div>
        </div>
    </div>

    <!-- Favorites Modal -->
    <div id="favorites-modal" class="favorites-modal-container hidden">
        <div id="favorites-modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 id="favorites-title" class="text-2xl font-bold">My Favorites</h2>
                <button id="favorites-close-btn" class="text-2xl text-gray-500 hover:text-white">&times;</button>
            </div>
            <div id="favorites-list"></div>
        </div>
    </div>


    <script type="module">
        // IMPORTANT: Replace this with your actual Cloudflare Worker URL
        const WORKER_URL = "https://moodfinder.callofdutysin.workers.dev"; 
        
        // API keys have been removed from here for security. They are now in the Cloudflare Worker.
        
        const ui = {
            moodForm: document.getElementById('mood-form'),
            moodInput: document.getElementById('mood-input'),
            yearFromInput: document.getElementById('year-from'),
            yearToInput: document.getElementById('year-to'),
            yearRangeLabel: document.getElementById('year-range-label'),
            genreInput: document.getElementById('genre-input'),
            genreLabel: document.getElementById('genre-label'),
            loader: document.getElementById('loader'),
            errorMessage: document.getElementById('error-message'),
            results: document.getElementById('results'),
            resetContainer: document.getElementById('reset-container'),
            resetButton: document.getElementById('reset-button'),
            refreshButton: document.getElementById('refresh-button'),
            header: document.getElementById('header'),
            optionsPanel: document.getElementById('options-panel'),
            langSwitcher: document.getElementById('lang-switcher'),
            headerTitle: document.getElementById('header-title'),
            headerSubtitle: document.getElementById('header-subtitle'),
            headerExplanation: document.getElementById('header-explanation'),
            submitButton: document.getElementById('submit-button'),
            loaderText: document.getElementById('loader-text'),
            errorText: document.getElementById('error-text'),
            favoritesModal: document.getElementById('favorites-modal'),
            favoritesOpenBtn: document.getElementById('favorites-open-btn'),
            favoritesCloseBtn: document.getElementById('favorites-close-btn'),
            favoritesTitle: document.getElementById('favorites-title'),
            favoritesList: document.getElementById('favorites-list'),
        };

        const translations = {
            en: {
                title: "Find Your Vibe", subtitle: "Describe your mood, I'll handle the magic!", explanation: "This website uses artificial intelligence to analyze your mood and suggest personalized movies, series, and songs to match your feelings. Just describe how you feel, and let us find the perfect vibe for you.", placeholder: "e.g., I feel super energetic and happy today...", submitButton: "Get Recommendations", loaderText: "Finding the perfect recommendations for you...", errorText: "Sorry, something went wrong. Please try again.", resetButton: "Try Again", refreshButton: "New Suggestions", yearRangeLabel: "Year Range:", genreLabel: "Genre:", genrePlaceholder: "Action, Comedy, Drama...", movieTitle: "Movie Recommendations", seriesTitle: "TV Series Recommendations", songTitle: "Song Recommendations", imdbButton: "IMDb", trailerButton: "Trailer", favoritesTitle: "My Favorites", noFavorites: "You haven't added any favorites yet.", optionalNote: "(Year and genre are optional)"
            },
            fa: {
                title: "حس و حالتو پیدا کن", subtitle: "احساست رو بنویس، جادوش با من!", explanation: "این وب‌سایت با استفاده از هوش مصنوعی، حس و حال شما را تحلیل کرده و فیلم‌ها، سریال‌ها و آهنگ‌های مناسبی را به شما پیشنهاد می‌دهد. کافیست احساستان را توصیف کنید تا ما بهترین‌ها را برایتان پیدا کنیم.", placeholder: "مثلاً: امروز حسابی پرانرژی و شادم...", submitButton: "بهم پیشنهاد بده", loaderText: "دارم بهترین‌ها رو برات پیدا می‌کنم...", errorText: "متاسفانه مشکلی پیش اومد. لطفاً دوباره تلاش کنید.", resetButton: "دوباره امتحان کن", refreshButton: "پیشنهاد جدید", yearRangeLabel: "بازه سال:", genreLabel: "ژانر:", genrePlaceholder: "اکشن، کمدی، درام...", movieTitle: "پیشنهاد فیلم", seriesTitle: "پیشنهاد سریال", songTitle: "پیشنهاد آهنگ", imdbButton: "IMDb", trailerButton: "تریلر", favoritesTitle: "لیست علاقه‌مندی‌ها", noFavorites: "شما هنوز موردی به علاقه‌مندی‌ها اضافه نکرده‌اید.", optionalNote: "(سال و ژانر اختیاری هستند)"
            }
        };

        // --- Mood-based Quotes ---
        const moodQuotes = {
            en: {
                sad: ["It's okay to feel sad, like a rainy day that passes.", "After the darkest nights come the brightest mornings.", "Your feelings are valid. Let the music be your comfort."],
                lonely: ["You are not alone in feeling lonely.", "Sometimes, the best company is a captivating story.", "Let these recommendations be a friend for a little while."],
                happy: ["Let's ride this wave of happiness!", "Time to turn up the volume and celebrate the good vibes!", "Awesome! Here's more fuel for your happy engine."],
                energetic: ["Let's match that energy!", "Time for something epic to keep the momentum going!", "Unleash that power! Here are some high-voltage picks."],
                hopeful: ["The future is bright. Let's find a story that shines with you.", "Hope is a powerful thing. Here's to dreams and new beginnings.", "Let's find something that mirrors your beautiful hope."],
                default: ["Searching for the perfect vibe...", "Let's see what we can find for you...", "Calibrating the recommendation engine..."]
            },
            fa: {
                sad: ["اشکالی نداره گاهی غمگین باشی، مثل یک روز بارونی که میگذره.", "بعد از تاریک‌ترین شب‌ها، روشن‌ترین صبح‌ها فرا می‌رسند.", "احساست معتبره. بذار موسیقی کمی آرومت کنه."],
                lonely: ["تو در این حس تنهایی، تنها نیستی.", "گاهی بهترین هم‌صحبت، یک داستان گیرا است.", "بذار این پیشنهادها برای چند ساعتی دوستت باشن."],
                happy: ["بیا سوار این موج شادی بشیم!", "وقتشه صدا رو بلند کنی و از این حال خوب لذت ببری!", "عالیه! اینم از سوخت بیشتر برای موتور خوشحالیت."],
                energetic: ["بریم که این انرژی رو دوچندان کنیم!", "وقتشه با یه چیز حماسی، این هیجان رو ادامه بدیم!", "این قدرت رو آزاد کن! اینم چندتا انتخاب پرانرژی."],
                hopeful: ["آینده روشنه. بیا داستانی پیدا کنیم که با تو بدرخشه.", "امید چیز قدرتمندیه. به سلامتی رویاها و شروع‌های جدید.", "بیا چیزی پیدا کنیم که بازتاب امید زیبای تو باشه."],
                default: ["در حال جستجو برای بهترین حس و حال...", "ببینم چی برات پیدا می‌کنم...", "در حال تنظیم موتور پیشنهادات..."]
            }
        };

        let currentLang = 'en';
        let lastMood = ''; 
        let recommendationHistory = { movies: [], series: [], songs: [] };
        let favorites = { movies: [], series: [], songs: [] };

        // --- FAVORITES LOGIC ---
        function loadFavorites() {
            const savedFavorites = localStorage.getItem('moodFavorites');
            if(savedFavorites) {
                favorites = JSON.parse(savedFavorites);
            }
        }
        function saveFavorites() {
            localStorage.setItem('moodFavorites', JSON.stringify(favorites));
        }
        function isFavorite(item, type) {
            return favorites[type].some(fav => fav.title === item.title && (fav.year ? fav.year === item.year : true));
        }
        function toggleFavorite(item, type, buttonEl) {
            const index = favorites[type].findIndex(fav => fav.title === item.title && (fav.year ? fav.year === item.year : true));
            if(index > -1) {
                favorites[type].splice(index, 1);
                buttonEl.classList.remove('favorited');
            } else {
                favorites[type].push(item);
                buttonEl.classList.add('favorited');
            }
            saveFavorites();
        }

        // --- UI State Management ---
        function showInitialState() {
            ui.header.classList.remove('hidden');
            ui.moodForm.classList.remove('hidden');
            ui.optionsPanel.classList.remove('hidden');
            ui.loader.classList.add('hidden');
            ui.errorMessage.classList.add('hidden');
            ui.results.classList.add('hidden');
            ui.moodInput.value = '';
            recommendationHistory = { movies: [], series: [], songs: [] };
        }

        function getQuoteForMood(mood, lang) {
            const lowerCaseMood = mood.toLowerCase();
            const quotesLang = moodQuotes[lang];
            const keywords = {
                sad: ['sad', 'depressed', 'crying', 'broken', 'hopeless', 'غمگین', 'ناراحت', 'افسرده', 'گریه', 'ناامید'],
                lonely: ['lonely', 'alone', 'isolated', 'تنها', 'منزوی'],
                happy: ['happy', 'joyful', 'excited', 'amazing', 'great', 'خوشحال', 'شاد', 'هیجان', 'عالی'],
                energetic: ['energetic', 'pumped', 'power', 'انرژی', 'پرانرژی', 'قدرت'],
                hopeful: ['hopeful', 'optimistic', 'امیدوار', 'خوشبین']
            };

            for (const moodKey in keywords) {
                if (keywords[moodKey].some(keyword => lowerCaseMood.includes(keyword))) {
                    const quotesArray = quotesLang[moodKey];
                    return quotesArray[Math.floor(Math.random() * quotesArray.length)];
                }
            }
            const defaultQuotes = quotesLang.default;
            return defaultQuotes[Math.floor(Math.random() * defaultQuotes.length)];
        }
        
        function showLoadingState(mood) {
            ui.header.classList.add('hidden');
            ui.moodForm.classList.add('hidden');
            ui.optionsPanel.classList.add('hidden');
            ui.loader.classList.remove('hidden');
            ui.errorMessage.classList.add('hidden');
            ui.results.classList.add('hidden');
            ui.loaderText.textContent = getQuoteForMood(mood, currentLang);
        }

        function showResultsState() {
            ui.header.classList.add('hidden');
            ui.moodForm.classList.add('hidden');
            ui.optionsPanel.classList.add('hidden');
            ui.loader.classList.add('hidden');
            ui.errorMessage.classList.add('hidden');
            ui.results.classList.remove('hidden');
        }

        function showErrorState() {
            ui.header.classList.add('hidden');
            ui.moodForm.classList.add('hidden');
            ui.optionsPanel.classList.add('hidden');
            ui.loader.classList.add('hidden');
            ui.errorMessage.classList.remove('hidden');
            ui.results.classList.add('hidden');
        }

        function setLanguage(lang) {
            currentLang = lang;
            const t = translations[lang];
            document.documentElement.lang = lang;
            document.documentElement.dir = lang === 'fa' ? 'rtl' : 'ltr';
            ui.headerTitle.textContent = t.title;
            ui.headerSubtitle.textContent = t.subtitle;
            ui.headerExplanation.textContent = t.explanation;
            ui.moodInput.placeholder = t.placeholder;
            ui.submitButton.textContent = t.submitButton;
            ui.loaderText.textContent = getQuoteForMood('', lang);
            ui.errorText.textContent = t.errorText;
            ui.resetButton.textContent = t.resetButton;
            ui.refreshButton.textContent = t.refreshButton;
            ui.yearRangeLabel.textContent = t.yearRangeLabel;
            ui.genreLabel.textContent = t.genreLabel;
            ui.genreInput.placeholder = t.genrePlaceholder;
            document.getElementById('optional-note').textContent = t.optionalNote;
            ui.favoritesTitle.textContent = t.favoritesTitle;
            ui.langSwitcher.querySelector(`button[data-lang="en"]`).classList.toggle('active', lang === 'en');
            ui.langSwitcher.querySelector(`button[data-lang="fa"]`).classList.toggle('active', lang === 'fa');
        }

        ui.langSwitcher.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const lang = e.target.dataset.lang;
                if (lang !== currentLang) setLanguage(lang);
            }
        });

        // --- CORE LOGIC ---
        async function handleSubmission(mood) {
            if (!mood) return;
            if (WORKER_URL === "YOUR_WORKER_URL_HERE") {
                alert("Please set your Cloudflare Worker URL in the script first!");
                return;
            }
            showLoadingState(mood);
            try {
                const startYear = ui.yearFromInput.value;
                const endYear = ui.yearToInput.value;
                
                // New robust gathering function
                const finalRecommendations = await gatherSufficientRecommendations(mood, startYear, endYear);

                // Add the finally chosen items to the global history
                recommendationHistory.movies.push(...(finalRecommendations.movies || []).map(m => m.title));
                recommendationHistory.series.push(...(finalRecommendations.series || []).map(s => s.title));
                recommendationHistory.songs.push(...(finalRecommendations.songs || []).map(s => s.title));
                
                await displayResults(finalRecommendations, currentLang);
                showResultsState();
            } catch (error) {
                console.error(">>> CRITICAL ERROR in submit handler:", error);
                showErrorState();
            }
        }

        // --- NEW: Robustly gather recommendations ---
        async function gatherSufficientRecommendations(mood, startYear, endYear) {
            const TARGET_COUNT = 5;
            const MAX_TRIES = 3;
            let tries = 0;

            const newRecommendations = {
                movies: [],
                series: [],
                songs: []
            };

            const historyCopy = {
                movies: new Set(recommendationHistory.movies),
                series: new Set(recommendationHistory.series),
                songs: new Set(recommendationHistory.songs)
            };

            while (
                (newRecommendations.movies.length < TARGET_COUNT || 
                 newRecommendations.series.length < TARGET_COUNT || 
                 newRecommendations.songs.length < TARGET_COUNT) && 
                tries < MAX_TRIES
            ) {
                tries++;
                console.log(`Recommendation attempt #${tries}`);

                const apiResponse = await getRecommendationsFromAPI(mood, currentLang, startYear, endYear, historyCopy);

                const filterAndAdd = (source, target, historySet) => {
                    if (source) {
                        for (const item of source) {
                            if (!historySet.has(item.title) && target.length < TARGET_COUNT) {
                                target.push(item);
                                historySet.add(item.title); // Add to history immediately to avoid duplicates in the same session
                            }
                        }
                    }
                };

                filterAndAdd(apiResponse.movies, newRecommendations.movies, historyCopy.movies);
                filterAndAdd(apiResponse.series, newRecommendations.series, historyCopy.series);
                filterAndAdd(apiResponse.songs, newRecommendations.songs, historyCopy.songs);
            }

            return newRecommendations;
        }

        ui.moodForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            recommendationHistory = { movies: [], series: [], songs: [] }; // Reset for new mood
            lastMood = ui.moodInput.value.trim();
            await handleSubmission(lastMood);
        });
        
        ui.refreshButton.addEventListener('click', async () => {
             // Do NOT reset history for a refresh
             await handleSubmission(lastMood);
        });

        ui.resetButton.addEventListener('click', showInitialState);
        
        // --- API & Data Functions ---
        async function getRecommendationsFromAPI(prompt, lang, startYear, endYear, currentHistorySets) {
            const reasonLang = lang === 'fa' ? 'Persian' : 'English';
            
            // Combine all seen titles into one list for the exclusion prompt
            const allHistory = [...currentHistorySets.movies, ...currentHistorySets.series, ...currentHistorySets.songs];
            let exclusionPrompt = '';
            if (allHistory.length > 0) {
                exclusionPrompt = `You have already recommended the following items: ${JSON.stringify(allHistory)}. Please provide a different set of recommendations.`;
            }

            let yearRangePrompt = '';
            if (startYear && endYear) {
                yearRangePrompt = `Please ensure all recommendations were released between ${startYear} and ${endYear}.`;
            } else if (startYear) {
                yearRangePrompt = `Please ensure all recommendations were released from ${startYear} onwards.`;
            } else if (endYear) {
                 yearRangePrompt = `Please ensure all recommendations were released up to ${endYear}.`;
            }

            const genreValue = ui.genreInput.value.trim();
            let genrePrompt = '';
            if (genreValue) {
                genrePrompt = `Please focus on these genres: ${genreValue}.`;
            }

            const chatHistory = [{
                role: "user", parts: [{
                    text: `Based on this mood: "${prompt}", give me 10 English/International movies, 10 series, and 10 songs.
                    ${yearRangePrompt}
                    ${genrePrompt}
                    For each, provide English title, director/creator/artist, year, and a short reason in **${reasonLang}**.
                    ${exclusionPrompt}
                    Response must be valid JSON.`
                }]
            }];

             const payload = { contents: chatHistory, generationConfig: { responseMimeType: "application/json",
                responseSchema: { type: "OBJECT", properties: {
                    "movies": { type: "ARRAY", items: { type: "OBJECT", properties: { "title": { "type": "STRING" }, "director": { "type": "STRING" }, "year": { "type": "STRING" }, "reason": { "type": "STRING" }}, required: ["title", "director", "year", "reason"] }},
                    "series": { type: "ARRAY", items: { type: "OBJECT", properties: { "title": { "type": "STRING" }, "creator": { "type": "STRING" }, "year": { "type": "STRING" }, "reason": { "type": "STRING" }}, required: ["title", "creator", "year", "reason"] }},
                    "songs": { type: "ARRAY", items: { type: "OBJECT", properties: { "title": { "type": "STRING" }, "artist": { "type": "STRING" }, "year": { "type": "STRING" }, "reason": { "type": "STRING" }}, required: ["title", "artist", "year", "reason"] }}
                }, required: ["movies", "series", "songs"]
            }}};
            
            // MODIFIED: Point to the Cloudflare Worker
            const apiUrl = `${WORKER_URL}/v1beta/models/gemini-2.0-flash:generateContent?service=gemini`;
            
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
            const result = await response.json();

            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0].text) {
                try {
                    const recommendations = JSON.parse(result.candidates[0].content.parts[0].text);
                    return {
                        movies: recommendations.movies || [],
                        series: recommendations.series || [],
                        songs: recommendations.songs || [],
                    };
                } catch (e) { throw new Error('Invalid JSON content from API'); }
            } else { throw new Error('Invalid response structure from API'); }
        }
        
        async function fetchMediaData(title, year, type = 'movie') {
            let mediaData = { posterUrl: null, imdbId: null, trailerKey: null, imdbRating: null };
            const tmdbType = type === 'series' ? 'tv' : 'movie';

            // MODIFIED: Point to the Cloudflare Worker for TMDB
            const tmdbSearchUrl = `${WORKER_URL}/3/search/${tmdbType}?service=tmdb&query=${encodeURIComponent(title)}&include_adult=false`;
            
            try {
                const searchRes = await fetch(tmdbSearchUrl);
                if (searchRes.ok) {
                    const searchData = await searchRes.json();
                    if (searchData.results && searchData.results.length > 0) {
                        let bestMatch = searchData.results[0];
                        const yearMatch = searchData.results.find(r => (r.release_date || r.first_air_date || '').substring(0, 4) === year.toString().substring(0,4));
                        if(yearMatch) bestMatch = yearMatch;

                        mediaData.posterUrl = bestMatch.poster_path ? `https://image.tmdb.org/t/p/w500${bestMatch.poster_path}` : null;
                        
                        // MODIFIED: Point to the Cloudflare Worker for TMDB details
                        const detailsUrl = `${WORKER_URL}/3/${tmdbType}/${bestMatch.id}?service=tmdb&append_to_response=videos,external_ids`;
                        const detailsRes = await fetch(detailsUrl);
                        if (detailsRes.ok) {
                            const detailsData = await detailsRes.json();
                            const trailer = detailsData.videos?.results?.find(v => v.site === 'YouTube' && v.type === 'Trailer');
                            mediaData.imdbId = detailsData.external_ids?.imdb_id;
                            mediaData.trailerKey = trailer?.key;
                        }
                    }
                }
            } catch (e) { console.error("Error fetching from TMDB via worker:", e); }

            if (!mediaData.posterUrl || !mediaData.imdbId || !mediaData.imdbRating) {
                try {
                    const omdbType = (type === 'tv' || type === 'series') ? 'series' : 'movie';
                    // MODIFIED: Point to the Cloudflare Worker for OMDB
                    const omdbUrl = `${WORKER_URL}/?service=omdb&t=${encodeURIComponent(title)}&y=${year}&type=${omdbType}`;
                    const omdbRes = await fetch(omdbUrl);
                    if (omdbRes.ok) {
                        const omdbData = await omdbRes.json();
                        if (omdbData.Response === "True") {
                            if (!mediaData.posterUrl && omdbData.Poster && omdbData.Poster !== 'N/A') mediaData.posterUrl = omdbData.Poster;
                            if (!mediaData.imdbId && omdbData.imdbID) mediaData.imdbId = omdbData.imdbID;
                            if (omdbData.imdbRating && omdbData.imdbRating !== 'N/A') mediaData.imdbRating = omdbData.imdbRating;
                        }
                    }
                } catch (e) { console.error("Error fetching from OMDB via worker:", e); }
            }
            return mediaData;
        }
        
         async function fetchSongCoverFromiTunes(artist, title) {
            const searchTerm = `${artist} ${title}`;
            // MODIFIED: Point to the Cloudflare Worker for iTunes
            const url = `${WORKER_URL}/search?service=itunes&term=${encodeURIComponent(searchTerm)}&entity=song&limit=1`;
            try {
                const res = await fetch(url);
                if(!res.ok) return null;
                const data = await res.json();
                if (data.results && data.results.length > 0 && data.results[0].artworkUrl100) {
                    return data.results[0].artworkUrl100.replace('100x100', '600x600');
                }
                return null;
            } catch (e) {
                console.error("iTunes API error via worker:", e);
                return null;
            }
        }

        function createPlaceholderSvg(iconUnicode) {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="240" height="350" viewBox="0 0 240 350" style="background-color: #1a202c;"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#2d3748;stop-opacity:1" /><stop offset="100%" style="stop-color:#1a202c;stop-opacity:1" /></linearGradient></defs><rect width="100%" height="100%" fill="url(#grad1)"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Font Awesome 5 Free" font-size="80" fill="#4a5568" font-weight="900">${iconUnicode}</text></svg>`;
            return `data:image/svg+xml;base64,${btoa(svg)}`;
        }

        function createSection(title, content) {
            if (!content || content.length === 0) return '';
            return `<div class="my-8">
                        <h2 class="text-2xl sm:text-3xl font-bold mb-6 border-b-2 border-purple-500 pb-2 inline-block">${title}</h2>
                        <div class="relative scroll-wrapper">
                             <button class="scroll-button prev"><i class="fas fa-chevron-left"></i></button>
                             <div class="horizontal-scroll-container">
                                ${content}
                             </div>
                             <button class="scroll-button next"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>`;
        }

        async function displayResults(data, lang) {
            const t = translations[lang];
            const { movies, series, songs } = data;

            const renderMovieCard = async (item, type) => {
                const cleanTitle = item.title.replace(/\s*\(Season\s*\d+\)/i, '').trim();
                const { posterUrl, imdbId, trailerKey, imdbRating } = await fetchMediaData(cleanTitle, item.year, type);
                
                const subtitle = type === 'movie' ? `${item.director} | ${item.year}` : `${item.creator} | ${item.year}`;
                const itemType = type === 'movie' ? 'movies' : 'series';
                const favClass = isFavorite(item, itemType) ? 'favorited' : '';
                
                let buttonsHTML = '';
                if(imdbId) buttonsHTML += `<a href="https://www.imdb.com/title/${imdbId}" target="_blank" class="footer-button">${t.imdbButton}</a>`;
                if(trailerKey) {
                    if(imdbId) buttonsHTML += '<div class="footer-divider"></div>';
                    buttonsHTML += `<a href="https://www.youtube.com/watch?v=${trailerKey}" target="_blank" class="footer-button">${t.trailerButton}</a>`;
                }

                const ratingHTML = imdbRating ? `<div class="imdb-rating"><i class="fas fa-star text-yellow-400 mr-1"></i><span>${imdbRating}</span></div>` : '';
                
                return `
                    <div class="item-card card-enter" data-title="${item.title}" data-type="${itemType}" data-year="${item.year}" data-subtitle="${type === 'movie' ? item.director : item.creator}" data-reason="${item.reason}">
                        ${ratingHTML}
                        <button class="favorite-btn ${favClass}"><i class="fas fa-heart"></i></button>
                        <div class="poster-container">
                            <img src="${posterUrl || createPlaceholderSvg('&#xf008;')}" alt="Poster for ${item.title}" onerror="this.onerror=null; this.src='${createPlaceholderSvg('&#xf008;')}';">
                            <div class="card-info"><h3 class="card-title">${item.title}</h3><p class="card-subtitle">${subtitle}</p></div>
                            <div class="card-reason"><p>${item.reason}</p></div>
                        </div>
                        ${buttonsHTML ? `<div class="card-footer">${buttonsHTML}</div>` : ''}
                    </div>`;
            };
            
            const renderSongCard = async (song) => {
                const coverUrl = await fetchSongCoverFromiTunes(song.artist, song.title);
                const encodedQuery = encodeURIComponent(`${song.artist} ${song.title}`);
                const favClass = isFavorite(song, 'songs') ? 'favorited' : '';
                return `
                    <div class="item-card card-enter" data-title="${song.title}" data-type="songs" data-year="${song.year}" data-subtitle="${song.artist}" data-reason="${song.reason}">
                        <button class="favorite-btn ${favClass}"><i class="fas fa-heart"></i></button>
                        <div class="poster-container">
                             <img src="${coverUrl || createPlaceholderSvg('&#xf001;')}" alt="Cover for ${song.title}" onerror="this.onerror=null; this.src='${createPlaceholderSvg('&#xf001;')}';">
                            <div class="card-info"><h3 class="card-title">${song.title}</h3><p class="card-subtitle">${song.artist} | ${song.year}</p></div>
                             <div class="card-reason"><p>${song.reason}</p></div>
                        </div>
                        <div class="card-footer streaming-links">
                            <a href="https://open.spotify.com/search/${encodedQuery}" target="_blank" title="Spotify" class="spotify"><i class="fab fa-spotify"></i></a>
                            <a href="https://music.youtube.com/search?q=${encodedQuery}" target="_blank" title="YouTube Music" class="youtube"><i class="fab fa-youtube"></i></a>
                            <a href="https://soundcloud.com/search?q=${encodedQuery}" target="_blank" title="SoundCloud" class="soundcloud"><i class="fab fa-soundcloud"></i></a>
                        </div>
                    </div>`;
            };
            
            const safePromise = (promise) => promise.catch(err => { console.error("A card failed to render:", err); return ""; });

            const movieCards = await Promise.all((movies || []).map(item => safePromise(renderMovieCard(item, 'movie'))));
            const seriesCards = await Promise.all((series || []).map(item => safePromise(renderMovieCard(item, 'series'))));
            const songCards = await Promise.all((songs || []).map(item => safePromise(renderSongCard(item))));
            
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = createSection(t.movieTitle, movieCards.join('')) + createSection(t.seriesTitle, seriesCards.join('')) + createSection(t.songTitle, songCards.join(''));
            resultsContainer.appendChild(ui.resetContainer);
            
            document.querySelectorAll('.card-enter').forEach((card, index) => { card.style.animationDelay = `${index * 100}ms`; });
            
            document.querySelectorAll('.item-card').forEach((card) => {
                const favBtn = card.querySelector('.favorite-btn');
                if (!favBtn) return;
                
                const item = {
                    title: card.dataset.title,
                    type: card.dataset.type,
                    year: card.dataset.year,
                    reason: card.dataset.reason,
                };
                if(item.type === 'movies') item.director = card.dataset.subtitle;
                if(item.type === 'series') item.creator = card.dataset.subtitle;
                if(item.type === 'songs') item.artist = card.dataset.subtitle;

                if(item.title && item.type) {
                    favBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFavorite(item, item.type, favBtn);
                    });
                }
            });

            document.querySelectorAll('.scroll-wrapper').forEach(setupScrollButtons);
        }

        function setupScrollButtons(wrapper) {
            const scrollContainer = wrapper.querySelector('.horizontal-scroll-container');
            const prevButton = wrapper.querySelector('.scroll-button.prev');
            const nextButton = wrapper.querySelector('.scroll-button.next');
            const scrollAmount = 300;
            
            let isScrolling = false;
            let scrollTimeout;
            
            function updateButtonState() {
                if(!scrollContainer) return;
                const isRTL = document.documentElement.dir === 'rtl';
                const scrollLeft = Math.abs(scrollContainer.scrollLeft); 
                const isOverflowing = scrollContainer.scrollWidth > scrollContainer.clientWidth;
                
                if (!isOverflowing) {
                    prevButton.classList.add('hidden');
                    nextButton.classList.add('hidden');
                    return;
                }
                prevButton.classList.remove('hidden');
                nextButton.classList.remove('hidden');

                if (isRTL) {
                     nextButton.classList.toggle('disabled', scrollLeft <= 0);
                     prevButton.classList.toggle('disabled', scrollLeft + scrollContainer.clientWidth >= scrollContainer.scrollWidth - 5);
                } else {
                    prevButton.classList.toggle('disabled', scrollLeft <= 0);
                    nextButton.classList.toggle('disabled', scrollLeft + scrollContainer.clientWidth >= scrollContainer.scrollWidth - 5);
                }
            }
            
            function smoothScroll(direction) {
                if (isScrolling) return;
                isScrolling = true;
                
                const cardWidth = 260 + 32; // card width + gap
                const scrollDistance = direction === 'next' ? cardWidth : -cardWidth;
                
                scrollContainer.scrollBy({ 
                    left: scrollDistance, 
                    behavior: 'smooth' 
                });
                
                setTimeout(() => {
                    isScrolling = false;
                }, 300);
            }

            prevButton.addEventListener('click', () => smoothScroll('prev'));
            nextButton.addEventListener('click', () => smoothScroll('next'));
            
            // Enhanced scroll with mouse wheel
            scrollContainer.addEventListener('wheel', (e) => {
                // Only handle horizontal scrolling if user is intentionally scrolling horizontally
                // or if they're hovering over a card and using vertical scroll
                const isHoveringCard = e.target.closest('.item-card');
                const isIntentionalHorizontal = Math.abs(e.deltaX) > Math.abs(e.deltaY);
                
                // If user is scrolling vertically and not hovering over a card, allow normal page scroll
                if (!isHoveringCard && !isIntentionalHorizontal) {
                    return;
                }
                
                // If horizontal scroll is intended, handle it
                if (isIntentionalHorizontal) {
                    e.preventDefault();
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const direction = e.deltaX > 0 ? 'next' : 'prev';
                        smoothScroll(direction);
                    }, 50);
                }
                // If hovering over card and scrolling vertically, convert to horizontal scroll
                else if (isHoveringCard) {
                    e.preventDefault();
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const direction = e.deltaY > 0 ? 'next' : 'prev';
                        smoothScroll(direction);
                    }, 50);
                }
            }, { passive: false });
            
            // Auto-scroll on hover at edges
            let autoScrollInterval;
            scrollContainer.addEventListener('mousemove', (e) => {
                const rect = scrollContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const edgeThreshold = 50;
                
                clearInterval(autoScrollInterval);
                
                if (x < edgeThreshold && !prevButton.classList.contains('disabled')) {
                    autoScrollInterval = setInterval(() => {
                        scrollContainer.scrollBy({ left: -2, behavior: 'auto' });
                    }, 16);
                } else if (x > rect.width - edgeThreshold && !nextButton.classList.contains('disabled')) {
                    autoScrollInterval = setInterval(() => {
                        scrollContainer.scrollBy({ left: 2, behavior: 'auto' });
                    }, 16);
                }
            });
            
            scrollContainer.addEventListener('mouseleave', () => {
                clearInterval(autoScrollInterval);
            });
            
            // Keyboard navigation
            scrollContainer.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    smoothScroll('prev');
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    smoothScroll('next');
                }
            });
            
            scrollContainer.addEventListener('scroll', updateButtonState);
            new ResizeObserver(updateButtonState).observe(scrollContainer);
            setTimeout(updateButtonState, 500);
        }

        function renderFavorites() {
            ui.favoritesList.innerHTML = '';
            const t = translations[currentLang];
            let content = '';

            const renderFavItem = (item, type, index) => {
                 const subtitle = type === 'songs' ? `${item.artist} | ${item.year}` : (item.director || item.creator) + ` | ${item.year}`;
                return `<div class="flex items-center justify-between p-2 rounded-lg hover:bg-gray-700">
                    <div>
                        <p class="font-bold">${item.title}</p>
                        <p class="text-sm text-gray-400">${subtitle}</p>
                    </div>
                    <button data-type="${type}" data-index="${index}" class="remove-fav-btn text-red-500 hover:text-red-400 text-lg">&times;</button>
                </div>`;
            };

            ['movies', 'series', 'songs'].forEach(type => {
                if(favorites[type] && favorites[type].length > 0) {
                     const titleKey = type === 'songs' ? 'songTitle' : (type === 'movies' ? 'movieTitle' : 'seriesTitle');
                     content += `<h3 class="text-xl font-bold mt-4 mb-2 text-purple-400">${t[titleKey]}</h3>`;
                     content += favorites[type].map((item, index) => renderFavItem(item, type, index)).join('');
                }
            });

            if(!content) {
                content = `<p class="text-center text-gray-500">${t.noFavorites}</p>`;
            }

            ui.favoritesList.innerHTML = content;
            ui.favoritesList.querySelectorAll('.remove-fav-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    const index = parseInt(btn.dataset.index, 10);
                    favorites[type].splice(index, 1);
                    saveFavorites();
                    renderFavorites();
                });
            });
        }

        ui.favoritesOpenBtn.addEventListener('click', () => {
            renderFavorites();
            ui.favoritesModal.classList.remove('hidden');
        });
        ui.favoritesCloseBtn.addEventListener('click', () => ui.favoritesModal.classList.add('hidden'));

        // --- Initial Setup ---
        ui.yearToInput.value = new Date().getFullYear();
        loadFavorites();
        setLanguage('fa'); // Set default language to Persian
        showInitialState();

    </script>
</body>
</html>
